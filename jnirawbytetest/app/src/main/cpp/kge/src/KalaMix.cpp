/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE WITHOUT COPYING TO YOUR SRC DIRECTORY.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues,
 * or contact author landerlyoung@gmail.com.
 */


#include <cstdlib>
#include "KalaMix.h"
#include "CMixSound.h"
#include "utils.h"

#ifdef DEBUG

#include <android/log.h>

#define LOGV(...)   __android_log_print((int)ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#define LOGD(...)   __android_log_print((int)ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGI(...)   __android_log_print((int)ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...)   __android_log_print((int)ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...)   __android_log_print((int)ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#else
#define LOGV(...)
#define LOGD(...)
#define LOGI(...)
#define LOGW(...)
#define LOGE(...)
#endif



//change to whatever you like
#define LOG_TAG "KalaMix"

namespace KalaMix {

struct MixContext {
public:
    CMixSound *const mixer;

    const int sampleRate;
    const bool dualChannel;
    const int bgmChannelCount;
    const int vocalChannelCount;

    MixContext(int sampeRate, int bgmChannelCount, int vocalChannelCount)
            : mixer(new CMixSound()),
              sampleRate(sampeRate),
              dualChannel(bgmChannelCount > 1 || vocalChannelCount > 1),
              bgmChannelCount(bgmChannelCount),
              vocalChannelCount(vocalChannelCount),
              buffer(nullptr),
              bufferSize(0)
    {
        mixer->Init(sampeRate, dualChannel ? 2 : 1);
    }

    inline jbyte *getBuffer(jint requiredBufferSize)
    {
        if (requiredBufferSize > bufferSize) {
            buffer = reinterpret_cast<jbyte *> (
                    std::realloc(buffer, sizeof(jbyte) * requiredBufferSize));
        }

        if (buffer) {
            bufferSize = requiredBufferSize;
        } else {
            //f**k, OOM!
        }

        return buffer;
    }

    ~MixContext()
    {
        if (buffer) {
            std::free(buffer);
        }
        if (mixer) {
            mixer->Uninit();
            delete mixer;
        }
    }

private:
    jbyte *buffer;
    jint bufferSize;
};

/*
 * Class:     com_young_jnirawbytetest_audiotest_KalaMix
 * Method:    private static long create(int sampleRate, int bgmChannelCount, int vocalChannelCount)
 * Signature: (III)J
 */
jlong create(JNIEnv *env, jclass clazz,
             jint sampleRate,
             jint bgmChannelCount,
             jint vocalChannelCount)
{
    LOGV("%s sampleRate:%d, bgmChannelCount:%d, vocalChannelCount:%d",
         __FUNCTION__, sampleRate, bgmChannelCount, vocalChannelCount);

    MixContext *ins = new MixContext(sampleRate, bgmChannelCount, vocalChannelCount);
    return reinterpret_cast<jlong>(ins);
}


/*
 * Class:     com_young_jnirawbytetest_audiotest_KalaMix
 * Method:    private static int process(long handel, byte[] bgm, int bgmSize, byte[] vocal, int vocalSize, byte[] out, int outSize)
 * Signature: (J[BI[BI[BI)I
 */
jint process(JNIEnv *env, jclass clazz,
             jlong handel,
             jbyteArray bgm, jint bgmSize,
             jbyteArray vocal, jint vocalSize,
             jbyteArray out, jint outSize) {

    MixContext *ins = reinterpret_cast<MixContext *>(handel);
    uint64_t start = radio::currentTimeUs();

    jboolean isBgmCopy;
    jbyte *bgmBytes = env->GetByteArrayElements(bgm, &isBgmCopy);
    char *bgmBuf = reinterpret_cast<char *>(bgmBytes);

    jboolean isVocalCopy;
    jbyte *vocalBytes = env->GetByteArrayElements(vocal, &isVocalCopy);
    char *vocalBuf = reinterpret_cast<char *>(vocalBytes);

    jboolean isOutCopy;
    jbyte *outBytes = env->GetByteArrayElements(out, &isOutCopy);
    char *outBuf = reinterpret_cast<char *>(outBytes);

    if (ins->dualChannel) {
        uint64_t s = radio::currentTimeUs();
        if (ins->bgmChannelCount == 1) {
            //expand bgm to stereo
            jbyte *tmpStereoBuf = ins->getBuffer(bgmSize << 1);
            radio::mono2stereo(
                    reinterpret_cast<uint8_t *>(bgmBytes),
                    static_cast<std::size_t>(bgmSize),
                    reinterpret_cast<uint8_t *>(tmpStereoBuf),
                    radio::LEFT | radio::RIGHT);

            LOGV("expand bgm to stereo");

            bgmBuf = reinterpret_cast<char *>(tmpStereoBuf);
            bgmSize <<= 1;
        } else if (ins->vocalChannelCount == 1) {
            //expand vocal to stereo
            jbyte *tmpStereoBuf = ins->getBuffer(vocalSize << 1);
            radio::mono2stereo(
                    reinterpret_cast<uint8_t *>(vocalBytes),
                    static_cast<std::size_t>(vocalSize),
                    reinterpret_cast<uint8_t *>(tmpStereoBuf),
                    radio::LEFT | radio::RIGHT);

            LOGV("expand vocal to stereo");

            vocalBuf = reinterpret_cast<char *>(tmpStereoBuf);
            vocalSize <<= 1;
        }
        LOGE("expand time %lld us" , radio::currentTimeUs() - start);
    }

    uint64_t p = radio::currentTimeUs();

    jint ret = ins->mixer->Process(
            bgmBuf, bgmSize,
            vocalBuf, vocalSize,
            outBuf, outSize);
    LOGI("process %lld us", radio::currentTimeUs() - p);

    env->ReleaseByteArrayElements(bgm, bgmBytes, JNI_ABORT);
    env->ReleaseByteArrayElements(vocal, vocalBytes, JNI_ABORT);
    env->ReleaseByteArrayElements(out, outBytes, 0);

    LOGI("%s execution time %lld us, audio time %lld us",
         __FUNCTION__,
         radio::currentTimeUs() - start,
         (uint64_t)outSize * 1000 * 1000 / (ins->dualChannel ? 4 : 2) / ins->sampleRate);
    return ret;
}

/*
 * Class:     com_young_jnirawbytetest_audiotest_KalaMix
 * Method:    private void release(long handel)
 * Signature: (J)V
 */
void release(JNIEnv *env, jobject thiz, jlong handel) {
    MixContext *ins = reinterpret_cast<MixContext *>(handel);
    delete ins;
}


static const JNINativeMethod gsNativeMethods[] = {
        {
                /* method name      */ const_cast<char *>("create"),
                /* method signature */ const_cast<char *>("(III)J"),
                /* function pointer */ reinterpret_cast<void *>(create)
        },
        {
                /* method name      */ const_cast<char *>("process"),
                /* method signature */ const_cast<char *>("(J[BI[BI[BI)I"),
                /* function pointer */ reinterpret_cast<void *>(process)
        },
        {
                /* method name      */ const_cast<char *>("release"),
                /* method signature */ const_cast<char *>("(J)V"),
                /* function pointer */ reinterpret_cast<void *>(release)
        }
};
static const int gsMethodCount =
        sizeof(gsNativeMethods) / sizeof(JNINativeMethod);

/**
 * register Native functions
 * @returns success or not
 */
bool registerNativeFunctions(JNIEnv *env)
{
    jclass clazz = env->FindClass(FULL_CLASS_NAME);
    return clazz != nullptr
           && 0 == env->RegisterNatives(clazz, gsNativeMethods, gsMethodCount);
}


} //endof namespace KalaMix

