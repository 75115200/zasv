/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE WITHOUT COPYING TO YOUR SRC DIRECTORY.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues,
 * or contact author landerlyoung@gmail.com.
 */
#include <algorithm>
#include <android/log.h>
#include "VoiceChangerWrapper.h"

#include "libvoicechanger.h"



#define LOGW(...)   __android_log_print((int)ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...)   __android_log_print((int)ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

#ifdef DEBUG
#define LOGV(...)   __android_log_print((int)ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#define LOGD(...)   __android_log_print((int)ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGI(...)   __android_log_print((int)ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#else
#define LOGV(...)
#define LOGD(...)
#define LOGI(...)
#endif


//change to whatever you like
static constexpr auto LOG_TAG = "VoiceChangerWrapper";

namespace VoiceChangerWrapper {

struct NativeContext {
    void *const voiceChangerInstance;
    jint sampleRate;
    jint channelCount;

    NativeContext(void *voiceChangeInstance) :
            voiceChangerInstance(voiceChangeInstance),
            sampleRate(0),
            channelCount(0)
    {
        libVoiceChangerReset_API(voiceChangeInstance);
    }

    ~NativeContext()
    {
        libVoiceChangerFree_API(voiceChangerInstance);
    }

};

/*
 * Class:     com_tencent_component_media_effect_VoiceChangerWrapper
 * Method:    private static long nativeCreate()
 * Signature: ()J
 */
jlong nativeCreate(JNIEnv *env, jclass clazz)
{
    void *ins;
    if (libVoiceChangerCreate_API(&ins) != 0 && ins != nullptr) {
        return 0;
    }
    NativeContext *n = new NativeContext(ins);

    return reinterpret_cast<jlong>(n);
}


/*
 * Class:     com_tencent_component_media_effect_VoiceChangerWrapper
 * Method:    private void nativeSetParam(long nativeHandel, int sampleRate, int channel, float tempoDelta, float pitchDelta, int voiceKind, int environment)
 * Signature: (JIIFFII)V
 */
void setParam(JNIEnv *env, jobject thiz, jlong nativeHandel, jint sampleRate, jint channel,
              jfloat tempoDelta, jfloat pitchDelta, jint voiceKind, jint environment)
{
    NativeContext *cxt = reinterpret_cast<NativeContext *>(nativeHandel);
    cxt->sampleRate = sampleRate;
    cxt->channelCount = channel;

    libVoiceChangerCalcu_API2(cxt->voiceChangerInstance,
                              sampleRate, channel,
                              tempoDelta, pitchDelta,
                              0, voiceKind,
                              environment, 2);
    LOGV("%s sampleRate:%d, channel:%d, tempoDelta:%f, pitchDelta:%f",
         __FUNCTION__, sampleRate, channel, tempoDelta, pitchDelta);
    return;
}


/*
 * Class:     com_tencent_component_media_effect_VoiceChangerWrapper
 * Method:    private int nativeProcess(long nativeHandel, byte[] inData, int inDatasize, byte[] outData, int outDatasize)
 * Signature: (J[BI[BI)I
 */
jint nativeProcess(JNIEnv *env, jobject thiz, jlong nativeHandel,
                   const jbyteArray inData, const jint inDataSize,
                   const jbyteArray outData, const jint outDataSize)
{
    LOGI("%s inData:%p inDataSize:%d outData:%p outDataSize:%d",
         __FUNCTION__, inData, inDataSize, outData, outDataSize);

    NativeContext *cxt = reinterpret_cast<NativeContext *>(nativeHandel);
    void *vcIns = cxt->voiceChangerInstance;

    jbyte *inDataBytes = env->GetByteArrayElements(inData, nullptr);
    jbyte *outDataBytes = env->GetByteArrayElements(outData, nullptr);

    jshort *inDataShorts = reinterpret_cast<jshort *>(inDataBytes);
    jshort *outDataShorts = reinterpret_cast<jshort *>(outDataBytes);

    jint inDataShortLen = inDataSize / 2;
    jint outDataShortLen = outDataSize / 2;

    jint inShortIndex = 0;
    jint outShortIndex = 0;

    //chunk is 20ms pcmData PCM16le
    const jint chunkSizeInShort = cxt->sampleRate * cxt->channelCount / 50;

    bool outBufferTooSmall = false;

    while (inShortIndex < inDataShortLen && outShortIndex < outDataShortLen) {
        const jint chunkSize = std::min(chunkSizeInShort, inDataShortLen - inShortIndex);

        jint outDataLeft = outDataShortLen - outShortIndex;

        jint processDataLen = 0;

        libVoiceChangerRun_API(
                vcIns,
                inDataShorts + inShortIndex, chunkSize,
                outDataShorts + outShortIndex, &processDataLen);

        if (processDataLen > outDataLeft) {
            //OMG! What a narrow escape!
            //We provided a buffer that is not long enough!
            //And we successfully escaped from a SIGSEGV crash!
            //Enlarge the out buffer right NOW! NOW! NOW!
            outBufferTooSmall = true;
            LOGE("%s outBufferTooSmall! processDataLen:%d > outDataLen:%d",
                 __FUNCTION__, processDataLen, outDataLeft);
            break;
        }

        LOGV("%s chunkSize %d outSize %d", __FUNCTION__, chunkSize, processDataLen);
        inShortIndex += chunkSize;
        outShortIndex += processDataLen;
    }

    env->ReleaseByteArrayElements(inData, inDataBytes, JNI_ABORT);
    env->ReleaseByteArrayElements(outData, outDataBytes, 0);

    LOGI("%s inSize:%d outArrayLen:%d outSize:%d",
         __FUNCTION__, inDataSize, outDataSize, outShortIndex * 2);

    jint dataLenInBytesMasked = outShortIndex * 2;

    if (outBufferTooSmall) {
        dataLenInBytesMasked |= OUT_BUFFER_TO_SMALL_MASK;
    }

    return dataLenInBytesMasked;
}


/*
 * Class:     com_tencent_component_media_effect_VoiceChangerWrapper
 * Method:    private void nativeRelease(long nativeHandel)
 * Signature: (J)V
 */
void nativeRelease(JNIEnv *env, jobject thiz, jlong nativeHandel)
{
    NativeContext *cxt = reinterpret_cast<NativeContext *>(nativeHandel);
    delete cxt;
}


static const JNINativeMethod gsNativeMethods[] = {
        {
                /* method name      */ const_cast<char *>("nativeCreate"),
                /* method signature */ const_cast<char *>("()J"),
                /* function pointer */ reinterpret_cast<void *>(nativeCreate)
        },
        {
                /* method name      */ const_cast<char *>("nativeSetParam"),
                /* method signature */ const_cast<char *>("(JIIFFII)V"),
                /* function pointer */ reinterpret_cast<void *>(setParam)
        },
        {
                /* method name      */ const_cast<char *>("nativeProcess"),
                /* method signature */ const_cast<char *>("(J[BI[BI)I"),
                /* function pointer */ reinterpret_cast<void *>(nativeProcess)
        },
        {
                /* method name      */ const_cast<char *>("nativeRelease"),
                /* method signature */ const_cast<char *>("(J)V"),
                /* function pointer */ reinterpret_cast<void *>(nativeRelease)
        }
};
static const int gsMethodCount =
        sizeof(gsNativeMethods) / sizeof(JNINativeMethod);

/**
 * register Native functions
 * @returns success or not
 */
bool registerNativeFunctions(JNIEnv *env)
{
    jclass clazz = env->FindClass(FULL_CLASS_NAME);
    return clazz != nullptr
           && 0 == env->RegisterNatives(clazz, gsNativeMethods, gsMethodCount);
}


} //endof namespace VoiceChangerWrapper


